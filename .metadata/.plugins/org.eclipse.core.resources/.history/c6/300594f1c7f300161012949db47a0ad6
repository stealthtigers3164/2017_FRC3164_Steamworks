package org.usfirst.frc.team3164.robot.auto;

import org.usfirst.frc.team3164.robot.electrical.motor.BasicMotor;
import org.usfirst.frc.team3164.robot.movement.DriveTrain;

/**
 * @notes 
 *
 * We need to keep track of time for testing puposes, and maybe even make it where
 * if the time is running out then it actually speeds up.  This will make it so that even if
 * we make it to slow, the robot will automatically speed up.  
 *
 *
 * 
 */
public class AutoDrive<T extends BasicMotor> {

	//Turn Variables
	
	//NOTE: This is the starting position of the robot, this is marked final so that nothing can
	//NOTE: accidentaly change the varible.
	private final RobotPosition m_startingPosition;
	
	//NOTE: This handles all turn handling.
	//NOTE: Meaning behind "turn handling": Whether or not there is another 
	//NOTE: turn or the robot is currently turning
	private TurnHandler m_turnHandler;
	
	//

	//Turn constants

	// - MIDDLE TURNING CONSTANTS

	//NOTE: This is when the robot should start turning to the side(The initial turn)
	private final double MIDDLE_START_TURN_DISTANCE = 1270;
	
	
	private final double MIDDLE_MOVE_TILL_PATH_TURN = 2819.4;

	//NOTE: This is the amount of units(feet, inches, meters, ?) that should
	//NOTE: trigger the second turn 
	private final double MIDDLE_TURN_DEGREE = 90;

	// - 
	// - SIDE TURNING CONSTANTS

	//NOTE: This is when the only turn should start
	private final double SIDE_START_TURN_DISTANCE = 2504.7448; //in mm

	//NOTE: This is when the robot should go foward to the peg
	private final double SIDE_STOP_TURNING_DEGREES = 60;
	
	// - 
	//

	//Sensor Variables

	//NOTE: What ever this class is, it needs to be able to provide the Distance from where it is 
	//private DistanceInputSensor m_distance;
	
	//NOTE: This is the class that you can call to get the degress traveled in a set amount of time
	//NOTE: also you should be able to get the length traveled too
	private GyroHandler m_gyroHandler;
	
	//

	//Motor/Driving Variables

	//I have no idea what is being used to be able to use the motors
	//so replace this with whatever does and then replace the mock functions 
	//with the real function
	private DriveTrain<T> m_driveTrain;

	//

	//Constructor
	//This initializes all of the variables that it needs to 
	public AutoDrive(int distanceInputSensorPort, DriveTrain<T> driveTrain, int gryoPort) {
		
		m_driveTrain = driveTrain;
		//m_distance = new DistanceInputSensor(distanceInputSensorPort);
		m_gyroHandler = new GyroHandler(gryoPort);
		m_startingPosition = findPositionOnField();
		m_turnHandler = new TurnHandler(m_startingPosition);
	}

	public void update() {
		if (m_turnHandler.isTurning()) {
			Turn currentTurn = m_turnHandler.getActiveTurn();
			double totalDegreesMoved = m_gyroHandler.getDegrees();
			continueTurning(currentTurn, totalDegreesMoved);
		}
		else {
			Turn lastTurn = m_turnHandler.getLastTurn();
			if () {
				
			}
		}
	}

	public void continueTurning(Turn currentTurn, double totalDegreesMoved) {
		currentTurn.turnedMore(totalDegreesMoved);

		double currentTurnTotalDegreesTurned = currentTurn.getTotalDegreesTurned();

		if (currentTurn.getPositon() == RobotPosition.MIDDLE) {
			
		}
		else {
			//TODO: Make it so that it does not have to be it completely but instead close to the
			// wanted value
			if (currentTurnTotalDegreesTurned < SIDE_STOP_TURNING_DEGREES) {
				if (currentTurn.getPositon() == RobotPosition.RIGHT) {
					m_driveTrain.turnLeftByDegrees(SIDE_STOP_TURNING_DEGREES - currentTurnTotalDegreesTurned);
				}
				else if (currentTurn.getPositon() == RobotPosition.LEFT) {
					m_driveTrain.turnRightByDegrees(SIDE_STOP_TURNING_DEGREES - currentTurnTotalDegreesTurned);
				}
			}
			else if (currentTurnTotalDegreesTurned == SIDE_STOP_TURNING_DEGREES) {
				currentTurn.turnComplete();
			} else if (currentTurnTotalDegreesTurned > SIDE_STOP_TURNING_DEGREES) {
				if (currentTurn.getPositon() == RobotPosition.RIGHT) {
					m_driveTrain.turnRightByDegrees(currentTurnTotalDegreesTurned - SIDE_STOP_TURNING_DEGREES);
				}
				else if (currentTurn.getPositon() == RobotPosition.LEFT) {
					m_driveTrain.turnLeftByDegrees(currentTurnTotalDegreesTurned - SIDE_STOP_TURNING_DEGREES);
				}
			}
		}
	}

	public double getDistance() {
		//TODO: Implement
		return 0;
	}

	public RobotPosition findPositionOnField() {
		//This needs implementation
		return null;
	}

	public void moveForwardToRemoval() {
		//Move forward specific amount to be decided on by Will

	}
}